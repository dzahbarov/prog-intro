## Домашнее задание 1. Запусти меня!

1. Скачайте исходный код ([RunMe.java](java/RunMe.java))
1. Откомпилируйте код (должен получиться `RunMe.class`)
1. Запустите класс `RunMe` с выданными вам аргументами командной строки
1. Следуйте выведенной инструкции


## Домашнее задание 2. Сумма чисел

1. Разработайте класс `Sum`, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
2. Аргументы могут содержать:

   * цифры;
   * знаки + и -; 
   * произвольные пробельные символы.
3. При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип int.
4. Перед выполнением задания ознакомьтесь с документацией к классам String и Integer.
5. Для отладочного вывода используйте System.err, тогда он будет игнорироваться проверяющей программой.

Исходный код тестов:

* [SumTest.java](java/sum/SumTest.java)
* [SumChecker.java](java/sum/SumChecker.java)
* [Базовые классы](java/base/)

Модификации:

* *Float*
   * Входные данные являются 32-битными числами с формате с плавающей точкой
   * Класс должен иметь имя `SumFloat`
   * [Исходный код тестов](java/sum/SumFloatTest.java)
   * [Откомпилированные тесты](artifacts/sum/SumFloatTest.jar)

   
## Домашнее задание 3. Реверс

1. Разработайте класс `Reverse`, читающий числа из стандартного ввода, и выводящий их на стандартный вывод в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (может быть 0). Числа разделены пробелами. Каждое число помещается в тип int.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке так же должен быть обратным к порядку чисел во входе.
4. Вход содержит не более 10^6 чисел и строк.
5. Для чтения чисел используйте класс Scanner.

Исходный код тестов:

* [ReverseTest.java](java/reverse/ReverseTest.java)
* [ReverseChecker.java](java/reverse/ReverseChecker.java)

Откомпилированные тесты: [ReverseTest.jar](artifacts/reverse/ReverseTest.jar)

Модификации:

* *Min*
   * Рассмотрим входные данные как (не полностью определенную) матрицу,
     вместо каждого числа выведите минимум из чисел в его столбце и строке
   * Класс должен иметь имя `ReverseMin`
   * [Исходный код тестов](java/reverse/ReverseMinTest.java)
   * [Откомпилированные тесты](artifacts/reverse/ReverseMinTest.jar)



## Домашнее задание 4. Подсчет слов

1. Разработайте класс `WordStat`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входной файл.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.

Исходный код тестов:

* [WordStatInputTest.java](java/wordStat/WordStatInputTest.java)
* [WordStatChecker.java](java/wordStat/WordStatChecker.java)

Откомпилированные тесты: [WordStatInputTest.jar](artifacts/wordStat/WordStatInputTest.jar)

Модификации

* *InputShingles* 
   * Выходной файл должен содержать все различные подстроки длины 3
     слов встречающихся во входном файле, в порядке их появления.
     Слова длины меньшей 3 игнорируются.
   * Класс должен иметь имя `WordStatInputShingles`
   * [Исходный код тестов](java/wordStat/WordStatInputShinglesTest.java)
   * [Откомпилированные тесты](artifacts/wordStat/WordStatInputShinglesTest.jar)

   
## Домашнее задание 5. Свой сканнер

1. Реализуйте свой аналог класса Scanner на основе Reader.
2. Примените разработанный Scanner для решения задания «Реверс».
3. Примените разработанный Scanner для решения задания «Статистика слов».
4. Код, управляющий чтением должен быть общим.
5. Код, выделяющий числа и слова должен быть общим.
6. При реализации блочного чтения обратите внимание на слова/числа, пересекающие границы блоков, особенно — больше одного раза.

Исходный код тестов:

* [FastReverseTest.java](java/reverse/FastReverseTest.java)

Откомпилированные тесты: [FastReverseTest.jar](artifacts/reverse/FastReverseTest.jar)

Модификации

* *Abc* 
   * Во вводе и выводе используются числа, записаные буквами:
     нулю соответствует буква `a`, единице – `b` и так далее
   * Класс должен иметь имя `ReverseAbc`
   * [Исходный код тестов](java/reverse/FastReverseAbcTest.java)
   * [Откомпилированные тесты](artifacts/reverse/FastReverseAbcTest.jar)

   
## Домашнее задание 6. Подсчет слов++
1. Разработайте класс `WordStatIndex`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файла время.
6. Для реализации программы используйте Collections Framework.

Исходный код тестов:

* [WordStatIndexTest.java](java/wordStat/WordStatIndexTest.java)
* [WordStatIndexChecker.java](java/wordStat/WordStatIndexChecker.java)

Откомпилированные тесты: [WordStatIndexTest.jar](artifacts/wordStat/WordStatIndexTest.jar)

Модификации

* *SortedLineIndex* 
   * В выходном файле слова должны быть упорядочены в лексикографическом порядке
   * Вместо номеров вхождений во всем файле надо указывать
     `<номер строки>:<номер в строке>`
   * Класс должен иметь имя `WordStatSortedLineIndex`
   * [Исходный код тестов](java/wordStat/WordStatSortedLineIndexTest.java)
   * [Откомпилированные тесты](artifacts/wordStat/WordStatSortedLineIndexTest.jar)


## Домашнее задание 7. Разметка

1. Разработайте набор классов для текстовой разметки.
2. Класс `Paragraph` может содержать произвольное число других элементов разметки и текстовых элементов.
3. Класс `Text` – текстовый элемент.
4. Классы разметки `Emphasis`,` Strong`, `Strikeout` – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
5. Все классы должны реализовывать метод `toMarkdown(StringBuilder)`, которой должен генерировать Markdown-разметку по следующим правилам:
   1. текстовые элементы выводятся как есть;
   2. выделенный текст окружается символами '*'; 
   3. сильно выделенный текст окружается символами '__'; 
   4. зачеркнутый текст окружается символами '~'.
6. Следующий код должен успешно компилироваться:
   ```
    Paragraph paragraph = new Paragraph(List.of(
     new Strong(List.of(
         new Text("1"),
         new Strikeout(List.of(
             new Text("2"),
             new Emphasis(List.of(
                 new Text("3"),
                 new Text("4")
             )),
             new Text("5")
         )),
         new Text("6")
     ))
   ));
      ```
Вызов `paragraph.toMakdown(new StringBuilder())` должен заполнять переданный StringBuilder следующим содержимым:
   `__1~2*34*5~6__`
7. Разработанные классы должны находиться в пакете markup.


Исходный код тестов:

* [MarkdownTest.java](java/markup/MarkdownTest.java)
* [AbstractTest.java](java/markup/AbstractTest.java)

Модификации

* *BBCode* 
   * Дополнительно реализуйте метод `toBBCode`, генерирующий [BBCode](https://en.wikipedia.org/wiki/BBCode)-разметку:
      * выделеный текст окружается тегом `i`;
      * сильно выделеный текст окружается тегом `b`;
      * зачеркнутый текст окружается тегом `s`.
   * [Исходный код тестов](java/markup/BBCodeTest.java)


## Домашнее задание 9. Игра m,n,k

1. Реализуйте игру m,n,k.
2. Добавьте обработку ошибок ввода пользователя.
3. Проверку выигрыша можно производить за O(nmk).

Модификации

* *Турнир*
   * Добавьте поддержку кругового турнира для нескольких участников из _c_ кругов
   * Выведите таблицу очков по схеме:
      * 3 очка за победу
      * 1 очко за ничью
      * 0 очков за поражение

## Домашнее задание 10. Выражения

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной переменной в типе int.
2. Классы должны позволять составлять выражения вида
   ```
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).evaluate(5)
   ```
   При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
3. Метод `toString` должен выдавать запись выражения в полноскобочной форме. Например
   ```
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).toString()
   ```
   должен выдавать `((2 * x) - 3)`.


Модификации
* *Базовая*
   * Реализуйте интерфейс [Expression](java/expression/Expression.java)
   * [Исходный код тестов](java/expression/ExpressionTest.java)
      * Запускать c аргументом `easy` или `hard`
* *Triple*
   * Дополнительно реализуйте интерфейс [TripleExpression](java/expression/TripleExpression.java)
   * [Исходный код тестов](java/expression/TripleExpressionTest.java)



## Домашнее задание 11. Разбор выражений

1. Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
   `x * (x - 2)*x + 1`
2. В записи выражения могут встречаться: умножение *, деление /, сложение +, вычитание -, унарный минус -, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные (x) и произвольное число пробельных символов в любом месте (но не внутри констант).
3. Приоритет операторов, начиная с наивысшего
   1. унарный минус;
   2. умножение и деление;
   3. сложение и вычитание.
   
4. Разбор выражений рекомендуется производить методом рекурсивного спуска. Алгоритм должен работать за линейное время.

Модификации
* *Базовая*
   * Класс `ExpressionParser` должен реализовывать интерфейс
     [Parser](java/expression/parser/Parser.java)
   * Результат разбора должен реализовывать интерфейс
     [TripleExpression](java/expression/TripleExpression.java)
   * [Исходный код тестов](java/expression/parser/ParserTest.java)
* *Bitwise* 
   * Дополнительно реализуйте бинарные операции:
      * `&` – побитное И, приоритет меньше чем у `+` (`6 & 1 + 2` равно `6 & (1 + 2)` равно 2);
      * `^` – побитный XOR, приоритет меньше чем у `&` (`6 ^ 1 + 2` равно `6 ^ (1 + 2)` равно 5);
      * `|` – побитное ИЛИ, приоритет меньше чем у `^` (`6 | 1 + 2` равно `6 | (1 + 2)` равно 7);
   * [Исходный код тестов](java/expression/parser/ParserBitwiseTest.java)
   

## Домашнее задание 12. Обработка ошибок

1. Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
   * ошибки разбора выражений; 
   * ошибки вычисления выражений.
   
2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
   ```
   x       f
   0       0
   1       division by zero
   2       32000000
   3       121500000
   4       341333333
   5       overflow
   6       overflow
   7       overflow
   8       overflow
   9       overflow
   10      overflow
   ```
   Результат `division by zero (overflow)` означает, что в процессе вычисления произошло деление на ноль (переполнение).
4. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
5. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
6. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).


Модификации
* *Базовая*
   * Класс `ExpressionParser` должен реализовывать интерфейс
     [Parser](java/expression/exceptions/Parser.java)
   * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
     `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
     [TripleExpression](java/expression/TripleExpression.java)
   * Нельзя использовать типы `long` и `double`
   * Нельзя использовать методы классов `Math` и `StrictMath`
   * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
* *AbsSqrt* 
   * Дополнительно реализуйте унарные операции:
      * `abs` – модуль числа, `abs -5` равно 5;
      * `sqrt` – квадратный корень, `sqrt 24` равно 4.
   * [Исходный код тестов](java/expression/exceptions/ExceptionsAbsSqrtTest.java)
















